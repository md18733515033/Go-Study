1. 函数定义
Go 语言函数定义格式如下：

func function_name( [parameter list] ) [return_types] {
   函数体
}
2. 函数定义解析：

func：函数由 func 开始声明
function_name：函数名称，函数名和参数列表一起构成了函数签名。
parameter list：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数。
return_types：返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。
函数体：函数定义的代码集合。

3. 函数和方法的异同:
    在java中,一般认为函数就是方法,方法就是函数
    在python中,一般认为类下面的函数叫方法,不在类下面的叫函数
    但是在go中,函数是指不属于任何结构体 类型的方法,也就是说函数是没有接受者的,而方法是有接收者的,我们所说的方法要么属于一个结构体,要么属于一个新定义的类型

声明一个外部定义的函数只需要给出函数名和函数签名,不需要写出完整的函数体
func hello(str, num int) // 外部实现

函数同样可以通过声明的方式作为一个函数类型被使用
type addNum func(int, int) int

4. 内置函数
close : 用于管道通信
len() : 用于返回某个类型的长度或数量(字符串, 数组, 切片, map 和 管道)
cap() : 容量的意思,用于返回某个类型的最大容量(只能用于切片和map)
new make : 均用于内存分配,不过new是用于值类型和用户定义的类型, 比如自定义结构, make用于内置引用类型(切片 map 管道) 他们的用法就像是函数,
            但是是将类型作为参数: new(type) , make(type).
            new(T)用于分配T类型的零值并返回其地址,也就是指向类型T的指针,也可以用于基本类型: v := new(int).
            make(T)返回类型的T初始化之后的值,因此他比new做更多工作
copy, append : 用户复制和连接切片
panic, recover: 两者均用于错误处理机制,panic类似于python中的raise, recover 类似于python中的try ... except ...
Print Println: 底层打印函数(部署环境中建议使用fmt包)

5. 函数传递机制
    1. go语言中的参数传递可以分为"按值传递"和"按引用传递".go语言默认按值传递,传递的是参数的副本,函数接收参数副本后,
        使用变量过程中可能会对副本的值进行更改,但不会影响原来的变量.(简而言之,调用函数时修改参数的值,不会影响原来的实参的值,因为数值变化
        只作用在副本上)
    2. 如果要让函数直接修改参数的值,而不是参数副本的值,就需要将参数的地址传递给函数,这就是按"引用传递",此时传递给函数的是一个指针
    3. 如果把指针传递给函数,指针的值(一个地址)就会被复制,但指针的值指向的地址上的那个值不会被复制(被复制的是指针,但是两个指针指向同一个实际的值).
        这样一来,修改这个指针的值,相当于这个值所指向的地址上的值被修改了(指针也是变量类型,也有自己的地址和值,通常指针的值指向一个变量的地址
        所以说按引用传递其实也是按值传递)
6. 传递指针的优点
    1. 传指针使得多个函数能操作同一个对象
    2. 传指针比较轻量级(8B),当结构体体积比较大时可以使用指针进行传递,降低系统开销.一般来说,传递指针比传递副本的消耗占用更少的资源
        在函数调用的时候,像切片 字典 接口 通道 这样的引用类型都是默认使用引用传递的(即使没有显示的指出指针)
        注意: channel slice map 这三种类型的实现机制类似指针,所以可以直接传递,而不用取地址后传递指针,不过若函数需要改变slice的长度,
        则仍需要取地址传递指针
    3. 传递指针给函数不但可以节省内存,而且赋予了函数直接改动外部变量的机会,所以被修改的变量不再需要return返回